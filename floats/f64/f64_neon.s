//go:build arm64 && !noasm
// DO NOT EDIT - generated by genasm.go

#include "textflag.h"

// func addConst8(dst, x *float64, c float64, n int)
TEXT ·addConst8(SB), NOSPLIT|NOFRAME, $0-32

        MOVD    dst(FP), R1
        MOVD    x+8(FP), R2
        MOVD    c+16(FP), R3
        MOVD    n+24(FP), R4

        LSL     $3, R4, R5
        ADD     R1, R5, R5            // end = dst + n*8

        VDUP    R3, V4.D2             // duplicate the value c into both lanes of the 128-bit vector register
Loop:

        // Arm64 Neon SIMD uses 2xfloat64 in 128bit registers. These are unrolled 4x.
        VLD1.P (R2), [V0.D2, V1.D2, V2.D2, V3.D2]

        WORD $0x4E64D400              // fadd v0.2d, v0.2d, v4.2d
        WORD $0x4E64D421              // fadd v1.2d, v1.2d, v4.2d
        WORD $0x4E64D442              // fadd v2.2d, v2.2d, v4.2d
        WORD $0x4E64D463              // fadd v3.2d, v3.2d, v4.2d

        VST1.P [V0.D2, V1.D2, V2.D2, V3.D2], (R1)

        CMP     R5, R1                // if dst >= end goto Done
        BGE     Done
        JMP     Loop

Done:
    RET


// func scale8(dst, x *float64, c float64, n int)
TEXT ·scale8(SB), NOSPLIT|NOFRAME, $0-32

        MOVD    dst(FP), R1
        MOVD    x+8(FP), R2
        MOVD    c+16(FP), R3
        MOVD    n+24(FP), R4

        LSL     $3, R4, R5
        ADD     R1, R5, R5            // end = dst + n*8

        VDUP    R3, V4.D2             // duplicate the value c into both lanes of the 128-bit vector register
Loop:

        // Arm64 Neon SIMD uses 2xfloat64 in 128bit registers. These are unrolled 4x.
        VLD1.P (R2), [V0.D2, V1.D2, V2.D2, V3.D2]

        WORD $0x6E64DC00              // fmul v0.2d, v0.2d, v4.2d
        WORD $0x6E64DC21              // fmul v1.2d, v1.2d, v4.2d
        WORD $0x6E64DC42              // fmul v2.2d, v2.2d, v4.2d
        WORD $0x6E64DC63              // fmul v3.2d, v3.2d, v4.2d

        VST1.P [V0.D2, V1.D2, V2.D2, V3.D2], (R1)

        CMP     R5, R1                // if dst >= end goto Done
        BGE     Done
        JMP     Loop

Done:
        RET

// func addScaled8(dst, x, y *float64, a float64, n int)
// dst[i] = a*x[i] + y[i]
TEXT ·addScaled8(SB), NOSPLIT|NOFRAME, $0-40

        MOVD    dst(FP), R1
        MOVD    x+8(FP), R2
        MOVD    y+16(FP), R3
        MOVD    a+24(FP), R4
        MOVD    n+32(FP), R5

        LSL     $3, R5, R6
        ADD     R1, R6, R6            // end = dst + n*8

        VDUP    R3, V8.D2             // duplicate the value a into both lanes of the 128-bit vector register
Loop:

        // Arm64 Neon SIMD uses 2xfloat64 in 128bit registers. These are unrolled 4x.
        VLD1.P (R2), [V0.D2, V1.D2, V2.D2, V3.D2]
        VLD1.P (R3), [V4.D2, V5.D2, V6.D2, V7.D2]

        WORD   $0x6E68DC00            // fmul v0.2d, v0.2d, v8.2d
        WORD   $0x6E68DC21            // fmul v1.2d, v1.2d, v8.2d
        WORD   $0x6E68DC42            // fmul v2.2d, v2.2d, v8.2d
        WORD   $0x6E68DC63            // fmul v3.2d, v3.2d, v8.2d

        WORD   $0x4E64D400            // fadd v0.2d, v0.2d, v4.2d
        WORD   $0x4E65D421            // fadd v1.2d, v1.2d, v5.2d
        WORD   $0x4E66D442            // fadd v2.2d, v2.2d, v6.2d
        WORD   $0x4E67D463            // fadd v3.2d, v3.2d, v7.2d

        VST1.P [V0.D2, V1.D2, V2.D2, V3.D2], (R1)

        CMP     R6, R1                // if dst >= end goto Done
        BGE     Done
        JMP     Loop
Done:
        RET
